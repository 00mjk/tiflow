// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dmmaster.proto

package pb

import (
	"fmt"
	io "io"
	math "math"

	proto "github.com/golang/protobuf/proto"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StartTaskRequest struct {
	Task                 string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Workers              []string `protobuf:"bytes,2,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartTaskRequest) Reset()         { *m = StartTaskRequest{} }
func (m *StartTaskRequest) String() string { return proto.CompactTextString(m) }
func (*StartTaskRequest) ProtoMessage()    {}
func (*StartTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{0}
}
func (m *StartTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StartTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartTaskRequest.Merge(dst, src)
}
func (m *StartTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartTaskRequest proto.InternalMessageInfo

func (m *StartTaskRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *StartTaskRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

type StartTaskResponse struct {
	Result               bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers              []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *StartTaskResponse) Reset()         { *m = StartTaskResponse{} }
func (m *StartTaskResponse) String() string { return proto.CompactTextString(m) }
func (*StartTaskResponse) ProtoMessage()    {}
func (*StartTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{1}
}
func (m *StartTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *StartTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartTaskResponse.Merge(dst, src)
}
func (m *StartTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *StartTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StartTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StartTaskResponse proto.InternalMessageInfo

func (m *StartTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *StartTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *StartTaskResponse) GetWorkers() []*CommonWorkerResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

type UpdateMasterConfigRequest struct {
	Config               string   `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateMasterConfigRequest) Reset()         { *m = UpdateMasterConfigRequest{} }
func (m *UpdateMasterConfigRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateMasterConfigRequest) ProtoMessage()    {}
func (*UpdateMasterConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{2}
}
func (m *UpdateMasterConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMasterConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMasterConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateMasterConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMasterConfigRequest.Merge(dst, src)
}
func (m *UpdateMasterConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMasterConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMasterConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMasterConfigRequest proto.InternalMessageInfo

func (m *UpdateMasterConfigRequest) GetConfig() string {
	if m != nil {
		return m.Config
	}
	return ""
}

type UpdateMasterConfigResponse struct {
	Result               bool                   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string                 `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers              []*QueryStatusResponse `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpdateMasterConfigResponse) Reset()         { *m = UpdateMasterConfigResponse{} }
func (m *UpdateMasterConfigResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateMasterConfigResponse) ProtoMessage()    {}
func (*UpdateMasterConfigResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{3}
}
func (m *UpdateMasterConfigResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMasterConfigResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMasterConfigResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateMasterConfigResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMasterConfigResponse.Merge(dst, src)
}
func (m *UpdateMasterConfigResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMasterConfigResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMasterConfigResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMasterConfigResponse proto.InternalMessageInfo

func (m *UpdateMasterConfigResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *UpdateMasterConfigResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UpdateMasterConfigResponse) GetWorkers() []*QueryStatusResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

type OperateTaskRequest struct {
	Op                   TaskOp   `protobuf:"varint,1,opt,name=op,proto3,enum=pb.TaskOp" json:"op,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Workers              []string `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OperateTaskRequest) Reset()         { *m = OperateTaskRequest{} }
func (m *OperateTaskRequest) String() string { return proto.CompactTextString(m) }
func (*OperateTaskRequest) ProtoMessage()    {}
func (*OperateTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{4}
}
func (m *OperateTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OperateTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateTaskRequest.Merge(dst, src)
}
func (m *OperateTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *OperateTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OperateTaskRequest proto.InternalMessageInfo

func (m *OperateTaskRequest) GetOp() TaskOp {
	if m != nil {
		return m.Op
	}
	return TaskOp_InvalidOp
}

func (m *OperateTaskRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OperateTaskRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

type OperateTaskResponse struct {
	Op                   TaskOp                    `protobuf:"varint,1,opt,name=op,proto3,enum=pb.TaskOp" json:"op,omitempty"`
	Result               bool                      `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string                    `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers              []*OperateSubTaskResponse `protobuf:"bytes,4,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *OperateTaskResponse) Reset()         { *m = OperateTaskResponse{} }
func (m *OperateTaskResponse) String() string { return proto.CompactTextString(m) }
func (*OperateTaskResponse) ProtoMessage()    {}
func (*OperateTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{5}
}
func (m *OperateTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OperateTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateTaskResponse.Merge(dst, src)
}
func (m *OperateTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *OperateTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OperateTaskResponse proto.InternalMessageInfo

func (m *OperateTaskResponse) GetOp() TaskOp {
	if m != nil {
		return m.Op
	}
	return TaskOp_InvalidOp
}

func (m *OperateTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OperateTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *OperateTaskResponse) GetWorkers() []*OperateSubTaskResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

// UpdateTaskRequest used to update task after it has beed started
// task: task's configuration, yaml format
//       now, only support to update config for routes, filters, column-mappings, black-white-list
//       support update partial config for syncer, loader, etc later
// workers need to do update, empty for all workers in processing the task
type UpdateTaskRequest struct {
	Task                 string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Workers              []string `protobuf:"bytes,2,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateTaskRequest) Reset()         { *m = UpdateTaskRequest{} }
func (m *UpdateTaskRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateTaskRequest) ProtoMessage()    {}
func (*UpdateTaskRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{6}
}
func (m *UpdateTaskRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTaskRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTaskRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateTaskRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTaskRequest.Merge(dst, src)
}
func (m *UpdateTaskRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTaskRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTaskRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTaskRequest proto.InternalMessageInfo

func (m *UpdateTaskRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *UpdateTaskRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

type UpdateTaskResponse struct {
	Result               bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers              []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *UpdateTaskResponse) Reset()         { *m = UpdateTaskResponse{} }
func (m *UpdateTaskResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateTaskResponse) ProtoMessage()    {}
func (*UpdateTaskResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{7}
}
func (m *UpdateTaskResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTaskResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTaskResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UpdateTaskResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTaskResponse.Merge(dst, src)
}
func (m *UpdateTaskResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTaskResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTaskResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTaskResponse proto.InternalMessageInfo

func (m *UpdateTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *UpdateTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UpdateTaskResponse) GetWorkers() []*CommonWorkerResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

type QueryStatusListRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Workers              []string `protobuf:"bytes,2,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryStatusListRequest) Reset()         { *m = QueryStatusListRequest{} }
func (m *QueryStatusListRequest) String() string { return proto.CompactTextString(m) }
func (*QueryStatusListRequest) ProtoMessage()    {}
func (*QueryStatusListRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{8}
}
func (m *QueryStatusListRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryStatusListRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryStatusListRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueryStatusListRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryStatusListRequest.Merge(dst, src)
}
func (m *QueryStatusListRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryStatusListRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryStatusListRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryStatusListRequest proto.InternalMessageInfo

func (m *QueryStatusListRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryStatusListRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

type QueryStatusListResponse struct {
	Result               bool                   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string                 `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers              []*QueryStatusResponse `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *QueryStatusListResponse) Reset()         { *m = QueryStatusListResponse{} }
func (m *QueryStatusListResponse) String() string { return proto.CompactTextString(m) }
func (*QueryStatusListResponse) ProtoMessage()    {}
func (*QueryStatusListResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{9}
}
func (m *QueryStatusListResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryStatusListResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryStatusListResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *QueryStatusListResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryStatusListResponse.Merge(dst, src)
}
func (m *QueryStatusListResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryStatusListResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryStatusListResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryStatusListResponse proto.InternalMessageInfo

func (m *QueryStatusListResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *QueryStatusListResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *QueryStatusListResponse) GetWorkers() []*QueryStatusResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

// ShowDDLLocksRequest used to query DDL locks which are un-resolved
// task: task's name, empty for all tasks
// workers: worker need to query, empty for all workers
//          any DDL lock in which the worker is synced or unsynced will return
// if specify task and workers both, and workers not doing the task , it will return empty DDL locks
type ShowDDLLocksRequest struct {
	Task                 string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Workers              []string `protobuf:"bytes,2,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShowDDLLocksRequest) Reset()         { *m = ShowDDLLocksRequest{} }
func (m *ShowDDLLocksRequest) String() string { return proto.CompactTextString(m) }
func (*ShowDDLLocksRequest) ProtoMessage()    {}
func (*ShowDDLLocksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{10}
}
func (m *ShowDDLLocksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowDDLLocksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowDDLLocksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ShowDDLLocksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowDDLLocksRequest.Merge(dst, src)
}
func (m *ShowDDLLocksRequest) XXX_Size() int {
	return m.Size()
}
func (m *ShowDDLLocksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowDDLLocksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShowDDLLocksRequest proto.InternalMessageInfo

func (m *ShowDDLLocksRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *ShowDDLLocksRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

// DDLLock represents a DDL lock info (I known the name confused with DDLLockInfo, any suggestion?)
// it been sent from dm-master to dmctl
// ID: DDL lock generated ID
// task: lock's corresponding task name
// owner: lock's owner, a dm-worker
// DDL: DDL statement
// synced: already synced dm-workers
// unsynced: pending to sync dm-workers
type DDLLock struct {
	ID                   string   `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Task                 string   `protobuf:"bytes,2,opt,name=task,proto3" json:"task,omitempty"`
	Owner                string   `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	DDLs                 []string `protobuf:"bytes,4,rep,name=DDLs" json:"DDLs,omitempty"`
	Synced               []string `protobuf:"bytes,5,rep,name=synced" json:"synced,omitempty"`
	Unsynced             []string `protobuf:"bytes,6,rep,name=unsynced" json:"unsynced,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DDLLock) Reset()         { *m = DDLLock{} }
func (m *DDLLock) String() string { return proto.CompactTextString(m) }
func (*DDLLock) ProtoMessage()    {}
func (*DDLLock) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{11}
}
func (m *DDLLock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DDLLock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DDLLock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DDLLock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DDLLock.Merge(dst, src)
}
func (m *DDLLock) XXX_Size() int {
	return m.Size()
}
func (m *DDLLock) XXX_DiscardUnknown() {
	xxx_messageInfo_DDLLock.DiscardUnknown(m)
}

var xxx_messageInfo_DDLLock proto.InternalMessageInfo

func (m *DDLLock) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *DDLLock) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *DDLLock) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *DDLLock) GetDDLs() []string {
	if m != nil {
		return m.DDLs
	}
	return nil
}

func (m *DDLLock) GetSynced() []string {
	if m != nil {
		return m.Synced
	}
	return nil
}

func (m *DDLLock) GetUnsynced() []string {
	if m != nil {
		return m.Unsynced
	}
	return nil
}

type ShowDDLLocksResponse struct {
	Result               bool       `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string     `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Locks                []*DDLLock `protobuf:"bytes,3,rep,name=locks" json:"locks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ShowDDLLocksResponse) Reset()         { *m = ShowDDLLocksResponse{} }
func (m *ShowDDLLocksResponse) String() string { return proto.CompactTextString(m) }
func (*ShowDDLLocksResponse) ProtoMessage()    {}
func (*ShowDDLLocksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{12}
}
func (m *ShowDDLLocksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShowDDLLocksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShowDDLLocksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ShowDDLLocksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShowDDLLocksResponse.Merge(dst, src)
}
func (m *ShowDDLLocksResponse) XXX_Size() int {
	return m.Size()
}
func (m *ShowDDLLocksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ShowDDLLocksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ShowDDLLocksResponse proto.InternalMessageInfo

func (m *ShowDDLLocksResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *ShowDDLLocksResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *ShowDDLLocksResponse) GetLocks() []*DDLLock {
	if m != nil {
		return m.Locks
	}
	return nil
}

// UnlockDDLLockRequest used to unlock (resolve) DDL lock manually
// ID: DDL lock ID
// replaceOwner: dm-worker used to replace the original DDL lock's owner
// workers: dm-workers need to execute / skip DDL, empty for all dm-workers
//   replaceOwner in or not in workers are both fine
// forceRemove: force to remove the DDL lock even unlock fail
type UnlockDDLLockRequest struct {
	ID                   string   `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ReplaceOwner         string   `protobuf:"bytes,2,opt,name=replaceOwner,proto3" json:"replaceOwner,omitempty"`
	Workers              []string `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
	ForceRemove          bool     `protobuf:"varint,4,opt,name=forceRemove,proto3" json:"forceRemove,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnlockDDLLockRequest) Reset()         { *m = UnlockDDLLockRequest{} }
func (m *UnlockDDLLockRequest) String() string { return proto.CompactTextString(m) }
func (*UnlockDDLLockRequest) ProtoMessage()    {}
func (*UnlockDDLLockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{13}
}
func (m *UnlockDDLLockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockDDLLockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockDDLLockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UnlockDDLLockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockDDLLockRequest.Merge(dst, src)
}
func (m *UnlockDDLLockRequest) XXX_Size() int {
	return m.Size()
}
func (m *UnlockDDLLockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockDDLLockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockDDLLockRequest proto.InternalMessageInfo

func (m *UnlockDDLLockRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *UnlockDDLLockRequest) GetReplaceOwner() string {
	if m != nil {
		return m.ReplaceOwner
	}
	return ""
}

func (m *UnlockDDLLockRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

func (m *UnlockDDLLockRequest) GetForceRemove() bool {
	if m != nil {
		return m.ForceRemove
	}
	return false
}

type UnlockDDLLockResponse struct {
	Result               bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers              []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *UnlockDDLLockResponse) Reset()         { *m = UnlockDDLLockResponse{} }
func (m *UnlockDDLLockResponse) String() string { return proto.CompactTextString(m) }
func (*UnlockDDLLockResponse) ProtoMessage()    {}
func (*UnlockDDLLockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{14}
}
func (m *UnlockDDLLockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnlockDDLLockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnlockDDLLockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *UnlockDDLLockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnlockDDLLockResponse.Merge(dst, src)
}
func (m *UnlockDDLLockResponse) XXX_Size() int {
	return m.Size()
}
func (m *UnlockDDLLockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnlockDDLLockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnlockDDLLockResponse proto.InternalMessageInfo

func (m *UnlockDDLLockResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *UnlockDDLLockResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *UnlockDDLLockResponse) GetWorkers() []*CommonWorkerResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

// BreakWorkerDDLLockRequest represents a request for some dm-workers to force to break the DDL lock
// workers: dm-workers need to break DDL lock
// task: sub task's name
// removeLockID: DDLLockInfo's ID which need to remove
// execDDL: execute DDL which is blocking
// skipDDL: skip DDL which is blocking
//   execDDL and skipDDL can not specify both at the same time, but can specify neither
type BreakWorkerDDLLockRequest struct {
	Workers              []string `protobuf:"bytes,1,rep,name=workers" json:"workers,omitempty"`
	Task                 string   `protobuf:"bytes,2,opt,name=task,proto3" json:"task,omitempty"`
	RemoveLockID         string   `protobuf:"bytes,3,opt,name=removeLockID,proto3" json:"removeLockID,omitempty"`
	ExecDDL              bool     `protobuf:"varint,4,opt,name=execDDL,proto3" json:"execDDL,omitempty"`
	SkipDDL              bool     `protobuf:"varint,5,opt,name=skipDDL,proto3" json:"skipDDL,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BreakWorkerDDLLockRequest) Reset()         { *m = BreakWorkerDDLLockRequest{} }
func (m *BreakWorkerDDLLockRequest) String() string { return proto.CompactTextString(m) }
func (*BreakWorkerDDLLockRequest) ProtoMessage()    {}
func (*BreakWorkerDDLLockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{15}
}
func (m *BreakWorkerDDLLockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BreakWorkerDDLLockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BreakWorkerDDLLockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BreakWorkerDDLLockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BreakWorkerDDLLockRequest.Merge(dst, src)
}
func (m *BreakWorkerDDLLockRequest) XXX_Size() int {
	return m.Size()
}
func (m *BreakWorkerDDLLockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BreakWorkerDDLLockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BreakWorkerDDLLockRequest proto.InternalMessageInfo

func (m *BreakWorkerDDLLockRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

func (m *BreakWorkerDDLLockRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *BreakWorkerDDLLockRequest) GetRemoveLockID() string {
	if m != nil {
		return m.RemoveLockID
	}
	return ""
}

func (m *BreakWorkerDDLLockRequest) GetExecDDL() bool {
	if m != nil {
		return m.ExecDDL
	}
	return false
}

func (m *BreakWorkerDDLLockRequest) GetSkipDDL() bool {
	if m != nil {
		return m.SkipDDL
	}
	return false
}

type BreakWorkerDDLLockResponse struct {
	Result               bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers              []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *BreakWorkerDDLLockResponse) Reset()         { *m = BreakWorkerDDLLockResponse{} }
func (m *BreakWorkerDDLLockResponse) String() string { return proto.CompactTextString(m) }
func (*BreakWorkerDDLLockResponse) ProtoMessage()    {}
func (*BreakWorkerDDLLockResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{16}
}
func (m *BreakWorkerDDLLockResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BreakWorkerDDLLockResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BreakWorkerDDLLockResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BreakWorkerDDLLockResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BreakWorkerDDLLockResponse.Merge(dst, src)
}
func (m *BreakWorkerDDLLockResponse) XXX_Size() int {
	return m.Size()
}
func (m *BreakWorkerDDLLockResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BreakWorkerDDLLockResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BreakWorkerDDLLockResponse proto.InternalMessageInfo

func (m *BreakWorkerDDLLockResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *BreakWorkerDDLLockResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *BreakWorkerDDLLockResponse) GetWorkers() []*CommonWorkerResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

// SwitchWorkerRelayMasterRequest represents a request for some dm-workers to switch relay unit's master server
// workers: relay unit in these dm-workers need to switch master server
type SwitchWorkerRelayMasterRequest struct {
	Workers              []string `protobuf:"bytes,1,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwitchWorkerRelayMasterRequest) Reset()         { *m = SwitchWorkerRelayMasterRequest{} }
func (m *SwitchWorkerRelayMasterRequest) String() string { return proto.CompactTextString(m) }
func (*SwitchWorkerRelayMasterRequest) ProtoMessage()    {}
func (*SwitchWorkerRelayMasterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{17}
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchWorkerRelayMasterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SwitchWorkerRelayMasterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchWorkerRelayMasterRequest.Merge(dst, src)
}
func (m *SwitchWorkerRelayMasterRequest) XXX_Size() int {
	return m.Size()
}
func (m *SwitchWorkerRelayMasterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchWorkerRelayMasterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchWorkerRelayMasterRequest proto.InternalMessageInfo

func (m *SwitchWorkerRelayMasterRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

type SwitchWorkerRelayMasterResponse struct {
	Result               bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers              []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *SwitchWorkerRelayMasterResponse) Reset()         { *m = SwitchWorkerRelayMasterResponse{} }
func (m *SwitchWorkerRelayMasterResponse) String() string { return proto.CompactTextString(m) }
func (*SwitchWorkerRelayMasterResponse) ProtoMessage()    {}
func (*SwitchWorkerRelayMasterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{18}
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SwitchWorkerRelayMasterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SwitchWorkerRelayMasterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwitchWorkerRelayMasterResponse.Merge(dst, src)
}
func (m *SwitchWorkerRelayMasterResponse) XXX_Size() int {
	return m.Size()
}
func (m *SwitchWorkerRelayMasterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwitchWorkerRelayMasterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwitchWorkerRelayMasterResponse proto.InternalMessageInfo

func (m *SwitchWorkerRelayMasterResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *SwitchWorkerRelayMasterResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *SwitchWorkerRelayMasterResponse) GetWorkers() []*CommonWorkerResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

// OperateWorkerRelayRequest represents a request for some dm-workers to operate relay unit
type OperateWorkerRelayRequest struct {
	Op                   RelayOp  `protobuf:"varint,1,opt,name=op,proto3,enum=pb.RelayOp" json:"op,omitempty"`
	Workers              []string `protobuf:"bytes,2,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OperateWorkerRelayRequest) Reset()         { *m = OperateWorkerRelayRequest{} }
func (m *OperateWorkerRelayRequest) String() string { return proto.CompactTextString(m) }
func (*OperateWorkerRelayRequest) ProtoMessage()    {}
func (*OperateWorkerRelayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{19}
}
func (m *OperateWorkerRelayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateWorkerRelayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateWorkerRelayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OperateWorkerRelayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateWorkerRelayRequest.Merge(dst, src)
}
func (m *OperateWorkerRelayRequest) XXX_Size() int {
	return m.Size()
}
func (m *OperateWorkerRelayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateWorkerRelayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OperateWorkerRelayRequest proto.InternalMessageInfo

func (m *OperateWorkerRelayRequest) GetOp() RelayOp {
	if m != nil {
		return m.Op
	}
	return RelayOp_InvalidRelayOp
}

func (m *OperateWorkerRelayRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

type OperateWorkerRelayResponse struct {
	Op                   RelayOp                 `protobuf:"varint,1,opt,name=op,proto3,enum=pb.RelayOp" json:"op,omitempty"`
	Result               bool                    `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string                  `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers              []*OperateRelayResponse `protobuf:"bytes,4,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *OperateWorkerRelayResponse) Reset()         { *m = OperateWorkerRelayResponse{} }
func (m *OperateWorkerRelayResponse) String() string { return proto.CompactTextString(m) }
func (*OperateWorkerRelayResponse) ProtoMessage()    {}
func (*OperateWorkerRelayResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{20}
}
func (m *OperateWorkerRelayResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OperateWorkerRelayResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OperateWorkerRelayResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *OperateWorkerRelayResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperateWorkerRelayResponse.Merge(dst, src)
}
func (m *OperateWorkerRelayResponse) XXX_Size() int {
	return m.Size()
}
func (m *OperateWorkerRelayResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_OperateWorkerRelayResponse.DiscardUnknown(m)
}

var xxx_messageInfo_OperateWorkerRelayResponse proto.InternalMessageInfo

func (m *OperateWorkerRelayResponse) GetOp() RelayOp {
	if m != nil {
		return m.Op
	}
	return RelayOp_InvalidRelayOp
}

func (m *OperateWorkerRelayResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OperateWorkerRelayResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *OperateWorkerRelayResponse) GetWorkers() []*OperateRelayResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

type RefreshWorkerTasksRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RefreshWorkerTasksRequest) Reset()         { *m = RefreshWorkerTasksRequest{} }
func (m *RefreshWorkerTasksRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshWorkerTasksRequest) ProtoMessage()    {}
func (*RefreshWorkerTasksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{21}
}
func (m *RefreshWorkerTasksRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshWorkerTasksRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshWorkerTasksRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RefreshWorkerTasksRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshWorkerTasksRequest.Merge(dst, src)
}
func (m *RefreshWorkerTasksRequest) XXX_Size() int {
	return m.Size()
}
func (m *RefreshWorkerTasksRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshWorkerTasksRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshWorkerTasksRequest proto.InternalMessageInfo

type RefreshWorkerTasksMsg struct {
	Worker               string   `protobuf:"bytes,1,opt,name=worker,proto3" json:"worker,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RefreshWorkerTasksMsg) Reset()         { *m = RefreshWorkerTasksMsg{} }
func (m *RefreshWorkerTasksMsg) String() string { return proto.CompactTextString(m) }
func (*RefreshWorkerTasksMsg) ProtoMessage()    {}
func (*RefreshWorkerTasksMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{22}
}
func (m *RefreshWorkerTasksMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshWorkerTasksMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshWorkerTasksMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RefreshWorkerTasksMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshWorkerTasksMsg.Merge(dst, src)
}
func (m *RefreshWorkerTasksMsg) XXX_Size() int {
	return m.Size()
}
func (m *RefreshWorkerTasksMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshWorkerTasksMsg.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshWorkerTasksMsg proto.InternalMessageInfo

func (m *RefreshWorkerTasksMsg) GetWorker() string {
	if m != nil {
		return m.Worker
	}
	return ""
}

func (m *RefreshWorkerTasksMsg) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type RefreshWorkerTasksResponse struct {
	Result               bool                     `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Workers              []*RefreshWorkerTasksMsg `protobuf:"bytes,2,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *RefreshWorkerTasksResponse) Reset()         { *m = RefreshWorkerTasksResponse{} }
func (m *RefreshWorkerTasksResponse) String() string { return proto.CompactTextString(m) }
func (*RefreshWorkerTasksResponse) ProtoMessage()    {}
func (*RefreshWorkerTasksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{23}
}
func (m *RefreshWorkerTasksResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshWorkerTasksResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshWorkerTasksResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RefreshWorkerTasksResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshWorkerTasksResponse.Merge(dst, src)
}
func (m *RefreshWorkerTasksResponse) XXX_Size() int {
	return m.Size()
}
func (m *RefreshWorkerTasksResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshWorkerTasksResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshWorkerTasksResponse proto.InternalMessageInfo

func (m *RefreshWorkerTasksResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *RefreshWorkerTasksResponse) GetWorkers() []*RefreshWorkerTasksMsg {
	if m != nil {
		return m.Workers
	}
	return nil
}

type HandleSQLsRequest struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Op                   SQLOp    `protobuf:"varint,2,opt,name=op,proto3,enum=pb.SQLOp" json:"op,omitempty"`
	Args                 []string `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	BinlogPos            string   `protobuf:"bytes,4,opt,name=binlog_pos,json=binlogPos,proto3" json:"binlog_pos,omitempty"`
	Worker               string   `protobuf:"bytes,5,opt,name=worker,proto3" json:"worker,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HandleSQLsRequest) Reset()         { *m = HandleSQLsRequest{} }
func (m *HandleSQLsRequest) String() string { return proto.CompactTextString(m) }
func (*HandleSQLsRequest) ProtoMessage()    {}
func (*HandleSQLsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{24}
}
func (m *HandleSQLsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandleSQLsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandleSQLsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HandleSQLsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleSQLsRequest.Merge(dst, src)
}
func (m *HandleSQLsRequest) XXX_Size() int {
	return m.Size()
}
func (m *HandleSQLsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleSQLsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HandleSQLsRequest proto.InternalMessageInfo

func (m *HandleSQLsRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HandleSQLsRequest) GetOp() SQLOp {
	if m != nil {
		return m.Op
	}
	return SQLOp_SKIP
}

func (m *HandleSQLsRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *HandleSQLsRequest) GetBinlogPos() string {
	if m != nil {
		return m.BinlogPos
	}
	return ""
}

func (m *HandleSQLsRequest) GetWorker() string {
	if m != nil {
		return m.Worker
	}
	return ""
}

type HandleSQLsResponse struct {
	Result               bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg                  string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers              []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *HandleSQLsResponse) Reset()         { *m = HandleSQLsResponse{} }
func (m *HandleSQLsResponse) String() string { return proto.CompactTextString(m) }
func (*HandleSQLsResponse) ProtoMessage()    {}
func (*HandleSQLsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_dmmaster_0bcf23190dd9a7fe, []int{25}
}
func (m *HandleSQLsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandleSQLsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandleSQLsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HandleSQLsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandleSQLsResponse.Merge(dst, src)
}
func (m *HandleSQLsResponse) XXX_Size() int {
	return m.Size()
}
func (m *HandleSQLsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HandleSQLsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HandleSQLsResponse proto.InternalMessageInfo

func (m *HandleSQLsResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *HandleSQLsResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *HandleSQLsResponse) GetWorkers() []*CommonWorkerResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

func init() {
	proto.RegisterType((*StartTaskRequest)(nil), "pb.StartTaskRequest")
	proto.RegisterType((*StartTaskResponse)(nil), "pb.StartTaskResponse")
	proto.RegisterType((*UpdateMasterConfigRequest)(nil), "pb.UpdateMasterConfigRequest")
	proto.RegisterType((*UpdateMasterConfigResponse)(nil), "pb.UpdateMasterConfigResponse")
	proto.RegisterType((*OperateTaskRequest)(nil), "pb.OperateTaskRequest")
	proto.RegisterType((*OperateTaskResponse)(nil), "pb.OperateTaskResponse")
	proto.RegisterType((*UpdateTaskRequest)(nil), "pb.UpdateTaskRequest")
	proto.RegisterType((*UpdateTaskResponse)(nil), "pb.UpdateTaskResponse")
	proto.RegisterType((*QueryStatusListRequest)(nil), "pb.QueryStatusListRequest")
	proto.RegisterType((*QueryStatusListResponse)(nil), "pb.QueryStatusListResponse")
	proto.RegisterType((*ShowDDLLocksRequest)(nil), "pb.ShowDDLLocksRequest")
	proto.RegisterType((*DDLLock)(nil), "pb.DDLLock")
	proto.RegisterType((*ShowDDLLocksResponse)(nil), "pb.ShowDDLLocksResponse")
	proto.RegisterType((*UnlockDDLLockRequest)(nil), "pb.UnlockDDLLockRequest")
	proto.RegisterType((*UnlockDDLLockResponse)(nil), "pb.UnlockDDLLockResponse")
	proto.RegisterType((*BreakWorkerDDLLockRequest)(nil), "pb.BreakWorkerDDLLockRequest")
	proto.RegisterType((*BreakWorkerDDLLockResponse)(nil), "pb.BreakWorkerDDLLockResponse")
	proto.RegisterType((*SwitchWorkerRelayMasterRequest)(nil), "pb.SwitchWorkerRelayMasterRequest")
	proto.RegisterType((*SwitchWorkerRelayMasterResponse)(nil), "pb.SwitchWorkerRelayMasterResponse")
	proto.RegisterType((*OperateWorkerRelayRequest)(nil), "pb.OperateWorkerRelayRequest")
	proto.RegisterType((*OperateWorkerRelayResponse)(nil), "pb.OperateWorkerRelayResponse")
	proto.RegisterType((*RefreshWorkerTasksRequest)(nil), "pb.RefreshWorkerTasksRequest")
	proto.RegisterType((*RefreshWorkerTasksMsg)(nil), "pb.RefreshWorkerTasksMsg")
	proto.RegisterType((*RefreshWorkerTasksResponse)(nil), "pb.RefreshWorkerTasksResponse")
	proto.RegisterType((*HandleSQLsRequest)(nil), "pb.HandleSQLsRequest")
	proto.RegisterType((*HandleSQLsResponse)(nil), "pb.HandleSQLsResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MasterClient is the client API for Master service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MasterClient interface {
	StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskResponse, error)
	OperateTask(ctx context.Context, in *OperateTaskRequest, opts ...grpc.CallOption) (*OperateTaskResponse, error)
	UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*UpdateTaskResponse, error)
	QueryStatus(ctx context.Context, in *QueryStatusListRequest, opts ...grpc.CallOption) (*QueryStatusListResponse, error)
	// show un-resolved DDL locks
	ShowDDLLocks(ctx context.Context, in *ShowDDLLocksRequest, opts ...grpc.CallOption) (*ShowDDLLocksResponse, error)
	// used by dmctl to manually unlock DDL lock
	UnlockDDLLock(ctx context.Context, in *UnlockDDLLockRequest, opts ...grpc.CallOption) (*UnlockDDLLockResponse, error)
	UpdateMasterConfig(ctx context.Context, in *UpdateMasterConfigRequest, opts ...grpc.CallOption) (*UpdateMasterConfigResponse, error)
	// BreakDDLLock request some dm-workers to break a DDL lock
	// including remove DDLLockInfo and/or execute/skip DDL
	BreakWorkerDDLLock(ctx context.Context, in *BreakWorkerDDLLockRequest, opts ...grpc.CallOption) (*BreakWorkerDDLLockResponse, error)
	HandleSQLs(ctx context.Context, in *HandleSQLsRequest, opts ...grpc.CallOption) (*HandleSQLsResponse, error)
	// SwitchWorkerRelayMaster requests some dm-workers to switch relay unit's master server
	SwitchWorkerRelayMaster(ctx context.Context, in *SwitchWorkerRelayMasterRequest, opts ...grpc.CallOption) (*SwitchWorkerRelayMasterResponse, error)
	// OperateWorkerRelayTask requests some dm-workers to operate relay unit
	OperateWorkerRelayTask(ctx context.Context, in *OperateWorkerRelayRequest, opts ...grpc.CallOption) (*OperateWorkerRelayResponse, error)
	// used by dmctl, to force refresh the task -> workers mapper
	// it should be used rarely only when task -> workers mapper corrupted
	RefreshWorkerTasks(ctx context.Context, in *RefreshWorkerTasksRequest, opts ...grpc.CallOption) (*RefreshWorkerTasksResponse, error)
}

type masterClient struct {
	cc *grpc.ClientConn
}

func NewMasterClient(cc *grpc.ClientConn) MasterClient {
	return &masterClient{cc}
}

func (c *masterClient) StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskResponse, error) {
	out := new(StartTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/StartTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OperateTask(ctx context.Context, in *OperateTaskRequest, opts ...grpc.CallOption) (*OperateTaskResponse, error) {
	out := new(OperateTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/OperateTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*UpdateTaskResponse, error) {
	out := new(UpdateTaskResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UpdateTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) QueryStatus(ctx context.Context, in *QueryStatusListRequest, opts ...grpc.CallOption) (*QueryStatusListResponse, error) {
	out := new(QueryStatusListResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/QueryStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) ShowDDLLocks(ctx context.Context, in *ShowDDLLocksRequest, opts ...grpc.CallOption) (*ShowDDLLocksResponse, error) {
	out := new(ShowDDLLocksResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/ShowDDLLocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UnlockDDLLock(ctx context.Context, in *UnlockDDLLockRequest, opts ...grpc.CallOption) (*UnlockDDLLockResponse, error) {
	out := new(UnlockDDLLockResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UnlockDDLLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UpdateMasterConfig(ctx context.Context, in *UpdateMasterConfigRequest, opts ...grpc.CallOption) (*UpdateMasterConfigResponse, error) {
	out := new(UpdateMasterConfigResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/UpdateMasterConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) BreakWorkerDDLLock(ctx context.Context, in *BreakWorkerDDLLockRequest, opts ...grpc.CallOption) (*BreakWorkerDDLLockResponse, error) {
	out := new(BreakWorkerDDLLockResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/BreakWorkerDDLLock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) HandleSQLs(ctx context.Context, in *HandleSQLsRequest, opts ...grpc.CallOption) (*HandleSQLsResponse, error) {
	out := new(HandleSQLsResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/HandleSQLs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) SwitchWorkerRelayMaster(ctx context.Context, in *SwitchWorkerRelayMasterRequest, opts ...grpc.CallOption) (*SwitchWorkerRelayMasterResponse, error) {
	out := new(SwitchWorkerRelayMasterResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/SwitchWorkerRelayMaster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OperateWorkerRelayTask(ctx context.Context, in *OperateWorkerRelayRequest, opts ...grpc.CallOption) (*OperateWorkerRelayResponse, error) {
	out := new(OperateWorkerRelayResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/OperateWorkerRelayTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) RefreshWorkerTasks(ctx context.Context, in *RefreshWorkerTasksRequest, opts ...grpc.CallOption) (*RefreshWorkerTasksResponse, error) {
	out := new(RefreshWorkerTasksResponse)
	err := c.cc.Invoke(ctx, "/pb.Master/RefreshWorkerTasks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MasterServer is the server API for Master service.
type MasterServer interface {
	StartTask(context.Context, *StartTaskRequest) (*StartTaskResponse, error)
	OperateTask(context.Context, *OperateTaskRequest) (*OperateTaskResponse, error)
	UpdateTask(context.Context, *UpdateTaskRequest) (*UpdateTaskResponse, error)
	QueryStatus(context.Context, *QueryStatusListRequest) (*QueryStatusListResponse, error)
	// show un-resolved DDL locks
	ShowDDLLocks(context.Context, *ShowDDLLocksRequest) (*ShowDDLLocksResponse, error)
	// used by dmctl to manually unlock DDL lock
	UnlockDDLLock(context.Context, *UnlockDDLLockRequest) (*UnlockDDLLockResponse, error)
	UpdateMasterConfig(context.Context, *UpdateMasterConfigRequest) (*UpdateMasterConfigResponse, error)
	// BreakDDLLock request some dm-workers to break a DDL lock
	// including remove DDLLockInfo and/or execute/skip DDL
	BreakWorkerDDLLock(context.Context, *BreakWorkerDDLLockRequest) (*BreakWorkerDDLLockResponse, error)
	HandleSQLs(context.Context, *HandleSQLsRequest) (*HandleSQLsResponse, error)
	// SwitchWorkerRelayMaster requests some dm-workers to switch relay unit's master server
	SwitchWorkerRelayMaster(context.Context, *SwitchWorkerRelayMasterRequest) (*SwitchWorkerRelayMasterResponse, error)
	// OperateWorkerRelayTask requests some dm-workers to operate relay unit
	OperateWorkerRelayTask(context.Context, *OperateWorkerRelayRequest) (*OperateWorkerRelayResponse, error)
	// used by dmctl, to force refresh the task -> workers mapper
	// it should be used rarely only when task -> workers mapper corrupted
	RefreshWorkerTasks(context.Context, *RefreshWorkerTasksRequest) (*RefreshWorkerTasksResponse, error)
}

func RegisterMasterServer(s *grpc.Server, srv MasterServer) {
	s.RegisterService(&_Master_serviceDesc, srv)
}

func _Master_StartTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).StartTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/StartTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).StartTask(ctx, req.(*StartTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OperateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OperateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OperateTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OperateTask(ctx, req.(*OperateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UpdateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UpdateTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UpdateTask(ctx, req.(*UpdateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_QueryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStatusListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).QueryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/QueryStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).QueryStatus(ctx, req.(*QueryStatusListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_ShowDDLLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShowDDLLocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).ShowDDLLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/ShowDDLLocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).ShowDDLLocks(ctx, req.(*ShowDDLLocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UnlockDDLLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockDDLLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UnlockDDLLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UnlockDDLLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UnlockDDLLock(ctx, req.(*UnlockDDLLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UpdateMasterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMasterConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UpdateMasterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UpdateMasterConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UpdateMasterConfig(ctx, req.(*UpdateMasterConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_BreakWorkerDDLLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BreakWorkerDDLLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).BreakWorkerDDLLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/BreakWorkerDDLLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).BreakWorkerDDLLock(ctx, req.(*BreakWorkerDDLLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_HandleSQLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleSQLsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).HandleSQLs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/HandleSQLs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).HandleSQLs(ctx, req.(*HandleSQLsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_SwitchWorkerRelayMaster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchWorkerRelayMasterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).SwitchWorkerRelayMaster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/SwitchWorkerRelayMaster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).SwitchWorkerRelayMaster(ctx, req.(*SwitchWorkerRelayMasterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OperateWorkerRelayTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperateWorkerRelayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OperateWorkerRelayTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OperateWorkerRelayTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OperateWorkerRelayTask(ctx, req.(*OperateWorkerRelayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_RefreshWorkerTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshWorkerTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).RefreshWorkerTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/RefreshWorkerTasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).RefreshWorkerTasks(ctx, req.(*RefreshWorkerTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Master_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Master",
	HandlerType: (*MasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartTask",
			Handler:    _Master_StartTask_Handler,
		},
		{
			MethodName: "OperateTask",
			Handler:    _Master_OperateTask_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _Master_UpdateTask_Handler,
		},
		{
			MethodName: "QueryStatus",
			Handler:    _Master_QueryStatus_Handler,
		},
		{
			MethodName: "ShowDDLLocks",
			Handler:    _Master_ShowDDLLocks_Handler,
		},
		{
			MethodName: "UnlockDDLLock",
			Handler:    _Master_UnlockDDLLock_Handler,
		},
		{
			MethodName: "UpdateMasterConfig",
			Handler:    _Master_UpdateMasterConfig_Handler,
		},
		{
			MethodName: "BreakWorkerDDLLock",
			Handler:    _Master_BreakWorkerDDLLock_Handler,
		},
		{
			MethodName: "HandleSQLs",
			Handler:    _Master_HandleSQLs_Handler,
		},
		{
			MethodName: "SwitchWorkerRelayMaster",
			Handler:    _Master_SwitchWorkerRelayMaster_Handler,
		},
		{
			MethodName: "OperateWorkerRelayTask",
			Handler:    _Master_OperateWorkerRelayTask_Handler,
		},
		{
			MethodName: "RefreshWorkerTasks",
			Handler:    _Master_RefreshWorkerTasks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dmmaster.proto",
}

func (m *StartTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Task) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i += copy(dAtA[i:], m.Task)
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StartTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateMasterConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMasterConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Config) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Config)))
		i += copy(dAtA[i:], m.Config)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateMasterConfigResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMasterConfigResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperateTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperateTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
	}
	if m.Result {
		dAtA[i] = 0x10
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Task) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i += copy(dAtA[i:], m.Task)
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueryStatusListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryStatusListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *QueryStatusListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryStatusListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowDDLLocksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowDDLLocksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Task) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i += copy(dAtA[i:], m.Task)
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DDLLock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DDLLock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Task) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i += copy(dAtA[i:], m.Task)
	}
	if len(m.Owner) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Owner)))
		i += copy(dAtA[i:], m.Owner)
	}
	if len(m.DDLs) > 0 {
		for _, s := range m.DDLs {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Synced) > 0 {
		for _, s := range m.Synced {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Unsynced) > 0 {
		for _, s := range m.Unsynced {
			dAtA[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShowDDLLocksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShowDDLLocksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Locks) > 0 {
		for _, msg := range m.Locks {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UnlockDDLLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockDDLLockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.ReplaceOwner) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.ReplaceOwner)))
		i += copy(dAtA[i:], m.ReplaceOwner)
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.ForceRemove {
		dAtA[i] = 0x20
		i++
		if m.ForceRemove {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UnlockDDLLockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockDDLLockResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BreakWorkerDDLLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BreakWorkerDDLLockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Task) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i += copy(dAtA[i:], m.Task)
	}
	if len(m.RemoveLockID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.RemoveLockID)))
		i += copy(dAtA[i:], m.RemoveLockID)
	}
	if m.ExecDDL {
		dAtA[i] = 0x20
		i++
		if m.ExecDDL {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SkipDDL {
		dAtA[i] = 0x28
		i++
		if m.SkipDDL {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BreakWorkerDDLLockResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BreakWorkerDDLLockResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwitchWorkerRelayMasterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchWorkerRelayMasterRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SwitchWorkerRelayMasterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchWorkerRelayMasterResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperateWorkerRelayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateWorkerRelayRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OperateWorkerRelayResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateWorkerRelayResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
	}
	if m.Result {
		dAtA[i] = 0x10
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RefreshWorkerTasksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshWorkerTasksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RefreshWorkerTasksMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshWorkerTasksMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Worker) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Worker)))
		i += copy(dAtA[i:], m.Worker)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RefreshWorkerTasksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshWorkerTasksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HandleSQLsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleSQLsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.BinlogPos) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.BinlogPos)))
		i += copy(dAtA[i:], m.BinlogPos)
	}
	if len(m.Worker) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Worker)))
		i += copy(dAtA[i:], m.Worker)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *HandleSQLsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandleSQLsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintDmmaster(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *StartTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateMasterConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateMasterConfigResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperateTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperateTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTaskRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTaskResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryStatusListRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *QueryStatusListResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowDDLLocksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DDLLock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.DDLs) > 0 {
		for _, s := range m.DDLs {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if len(m.Synced) > 0 {
		for _, s := range m.Synced {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if len(m.Unsynced) > 0 {
		for _, s := range m.Unsynced {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShowDDLLocksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Locks) > 0 {
		for _, e := range m.Locks {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnlockDDLLockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.ReplaceOwner)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.ForceRemove {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnlockDDLLockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BreakWorkerDDLLockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.RemoveLockID)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.ExecDDL {
		n += 2
	}
	if m.SkipDDL {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BreakWorkerDDLLockResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwitchWorkerRelayMasterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SwitchWorkerRelayMasterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperateWorkerRelayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OperateWorkerRelayResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RefreshWorkerTasksRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RefreshWorkerTasksMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Worker)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RefreshWorkerTasksResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HandleSQLsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if len(m.Args) > 0 {
		for _, s := range m.Args {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	l = len(m.BinlogPos)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Worker)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HandleSQLsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDmmaster(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDmmaster(x uint64) (n int) {
	return sovDmmaster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StartTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &CommonWorkerResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMasterConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMasterConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMasterConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMasterConfigResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMasterConfigResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMasterConfigResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &QueryStatusResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (TaskOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (TaskOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &OperateSubTaskResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &CommonWorkerResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryStatusListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryStatusListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryStatusListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryStatusListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryStatusListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryStatusListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &QueryStatusResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowDDLLocksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowDDLLocksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowDDLLocksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DDLLock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DDLLock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DDLLock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DDLs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DDLs = append(m.DDLs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Synced", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Synced = append(m.Synced, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unsynced", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unsynced = append(m.Unsynced, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShowDDLLocksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShowDDLLocksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShowDDLLocksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locks = append(m.Locks, &DDLLock{})
			if err := m.Locks[len(m.Locks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockDDLLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockDDLLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockDDLLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplaceOwner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReplaceOwner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceRemove", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForceRemove = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockDDLLockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockDDLLockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockDDLLockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &CommonWorkerResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BreakWorkerDDLLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BreakWorkerDDLLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BreakWorkerDDLLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveLockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoveLockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecDDL", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ExecDDL = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipDDL", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SkipDDL = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BreakWorkerDDLLockResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BreakWorkerDDLLockResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BreakWorkerDDLLockResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &CommonWorkerResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchWorkerRelayMasterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchWorkerRelayMasterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchWorkerRelayMasterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &CommonWorkerResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateWorkerRelayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateWorkerRelayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateWorkerRelayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (RelayOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateWorkerRelayResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateWorkerRelayResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateWorkerRelayResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (RelayOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &OperateRelayResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshWorkerTasksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshWorkerTasksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshWorkerTasksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshWorkerTasksMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshWorkerTasksMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshWorkerTasksMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Worker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshWorkerTasksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshWorkerTasksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshWorkerTasksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &RefreshWorkerTasksMsg{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleSQLsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleSQLsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleSQLsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (SQLOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinlogPos", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BinlogPos = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Worker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandleSQLsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandleSQLsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandleSQLsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &CommonWorkerResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDmmaster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDmmaster
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDmmaster
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDmmaster(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDmmaster = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDmmaster   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("dmmaster.proto", fileDescriptor_dmmaster_0bcf23190dd9a7fe) }

var fileDescriptor_dmmaster_0bcf23190dd9a7fe = []byte{
	// 1006 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x57, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0x29, 0x4b, 0x8e, 0x46, 0xa9, 0x61, 0x6f, 0x6c, 0x99, 0x5a, 0xc3, 0xaa, 0xcb, 0x5e,
	0x7c, 0x32, 0x50, 0xb9, 0xa7, 0x00, 0x05, 0x92, 0x98, 0x08, 0x62, 0x40, 0x81, 0x6b, 0xaa, 0x46,
	0xd1, 0x4b, 0x0b, 0x4a, 0x5a, 0x2b, 0x82, 0x24, 0x2e, 0xc3, 0xa5, 0xe2, 0xba, 0x97, 0xde, 0x7a,
	0x29, 0x7a, 0xe8, 0xa9, 0xbd, 0xe6, 0x6d, 0x7a, 0xec, 0x23, 0x14, 0xee, 0x8b, 0x14, 0xfb, 0x43,
	0x72, 0xf9, 0xa7, 0x34, 0x3e, 0xe8, 0xb6, 0xbb, 0xc3, 0xfd, 0x66, 0xe6, 0x9b, 0xd9, 0x99, 0x21,
	0x6c, 0x8f, 0x17, 0x0b, 0x8f, 0x45, 0x24, 0x3c, 0x0d, 0x42, 0x1a, 0x51, 0x64, 0x06, 0x43, 0xbc,
	0x3d, 0x5e, 0xdc, 0xd2, 0x70, 0x16, 0x9f, 0xd9, 0xcf, 0x60, 0x67, 0x10, 0x79, 0x61, 0xf4, 0x8d,
	0xc7, 0x66, 0x2e, 0x79, 0xbb, 0x24, 0x2c, 0x42, 0x08, 0x36, 0x23, 0x8f, 0xcd, 0x2c, 0xe3, 0xd8,
	0x38, 0x69, 0xba, 0x62, 0x8d, 0x2c, 0xd8, 0x92, 0xf7, 0x98, 0x65, 0x1e, 0xd7, 0x4e, 0x9a, 0x6e,
	0xbc, 0xb5, 0xdf, 0xc2, 0xae, 0x86, 0xc0, 0x02, 0xea, 0x33, 0x82, 0xda, 0xd0, 0x08, 0x09, 0x5b,
	0xce, 0x23, 0x01, 0xf2, 0xc8, 0x55, 0x3b, 0xb4, 0x03, 0xb5, 0x05, 0x9b, 0x58, 0xa6, 0x40, 0xe6,
	0x4b, 0xd4, 0x4b, 0x81, 0x6b, 0xc7, 0xb5, 0x93, 0x56, 0xcf, 0x3a, 0x0d, 0x86, 0xa7, 0xe7, 0x74,
	0xb1, 0xa0, 0xfe, 0xb7, 0x42, 0x10, 0x83, 0xa6, 0x2a, 0xcf, 0xa0, 0x73, 0x1d, 0x8c, 0xbd, 0x88,
	0xbc, 0x16, 0xee, 0x9d, 0x53, 0xff, 0x66, 0x3a, 0x89, 0xad, 0x6f, 0x43, 0x63, 0x24, 0x0e, 0x94,
	0xfd, 0x6a, 0x67, 0xdf, 0x01, 0x2e, 0xbb, 0xf4, 0xd1, 0x06, 0x7f, 0x91, 0x37, 0xf8, 0x80, 0x1b,
	0x7c, 0xb5, 0x24, 0xe1, 0xdd, 0x20, 0xf2, 0xa2, 0x25, 0x2b, 0xda, 0xfb, 0x3d, 0xa0, 0xcb, 0x80,
	0x84, 0x5e, 0x44, 0x74, 0x9a, 0x31, 0x98, 0x34, 0x10, 0xea, 0xb6, 0x7b, 0xc0, 0x31, 0xb8, 0xf0,
	0x32, 0x70, 0x4d, 0x1a, 0xf0, 0x10, 0xf8, 0xde, 0x82, 0x28, 0xbd, 0x62, 0xad, 0x87, 0xa0, 0x96,
	0x0d, 0xc1, 0xef, 0x06, 0x3c, 0xc9, 0x28, 0x50, 0x4e, 0xad, 0xd2, 0x90, 0x3a, 0x6c, 0x96, 0x39,
	0x5c, 0x4b, 0x1d, 0xfe, 0x32, 0xd5, 0xbb, 0x29, 0x1c, 0xc6, 0x1c, 0x4a, 0xe9, 0x1b, 0x2c, 0x87,
	0xba, 0xca, 0xd4, 0xa6, 0xe7, 0xb0, 0x2b, 0xe9, 0x7e, 0x78, 0x66, 0x85, 0x80, 0x74, 0x88, 0xb5,
	0xa4, 0xd6, 0x4b, 0x68, 0x6b, 0xa1, 0xec, 0x4f, 0x59, 0xa4, 0xd9, 0x2e, 0x42, 0x62, 0x94, 0x87,
	0x24, 0x67, 0xfb, 0x3b, 0x38, 0x28, 0xe0, 0xac, 0x23, 0xd5, 0xce, 0xe1, 0xc9, 0xe0, 0x0d, 0xbd,
	0x75, 0x9c, 0x7e, 0x9f, 0x8e, 0x66, 0xec, 0x61, 0xc4, 0xff, 0x6a, 0xc0, 0x96, 0x42, 0x40, 0xdb,
	0x60, 0x5e, 0x38, 0xea, 0x9e, 0x79, 0xe1, 0x24, 0x48, 0xa6, 0x86, 0xb4, 0x07, 0x75, 0x7a, 0xeb,
	0x93, 0x50, 0x65, 0x8d, 0xdc, 0xf0, 0x2f, 0x1d, 0xa7, 0x2f, 0x93, 0xa6, 0xe9, 0x8a, 0x35, 0xf7,
	0x9d, 0xdd, 0xf9, 0x23, 0x32, 0xb6, 0xea, 0xe2, 0x54, 0xed, 0x10, 0x86, 0x47, 0x4b, 0x5f, 0x49,
	0x1a, 0x42, 0x92, 0xec, 0xed, 0x11, 0xec, 0x65, 0x5d, 0xfa, 0x68, 0x1e, 0x3f, 0x83, 0xfa, 0x9c,
	0x5f, 0x55, 0x2c, 0xb6, 0x38, 0x8b, 0x0a, 0xce, 0x95, 0x12, 0xfb, 0x17, 0x03, 0xf6, 0xae, 0x7d,
	0xbe, 0x8e, 0x05, 0x8a, 0xb9, 0xbc, 0xff, 0x36, 0x3c, 0x0e, 0x49, 0x30, 0xf7, 0x46, 0xe4, 0x52,
	0xb8, 0x2c, 0xd5, 0x64, 0xce, 0xaa, 0x5f, 0x2a, 0x3a, 0x86, 0xd6, 0x0d, 0x0d, 0x47, 0xc4, 0x25,
	0x0b, 0xfa, 0x8e, 0x58, 0x9b, 0xc2, 0x70, 0xfd, 0xc8, 0x5e, 0xc2, 0x7e, 0xce, 0x8e, 0xb5, 0xe4,
	0xfd, 0x7b, 0x03, 0x3a, 0x2f, 0x42, 0xe2, 0xcd, 0xe4, 0x07, 0x39, 0x12, 0x34, 0x87, 0x8c, 0xac,
	0x43, 0x65, 0xe9, 0x20, 0x28, 0xe2, 0xce, 0x70, 0x88, 0x0b, 0x47, 0x65, 0x45, 0xe6, 0x8c, 0x23,
	0x92, 0x1f, 0xc9, 0xc8, 0x71, 0xfa, 0x8a, 0x84, 0x78, 0xcb, 0x25, 0x6c, 0x36, 0x0d, 0xb8, 0xa4,
	0x2e, 0x25, 0x6a, 0x6b, 0xff, 0x04, 0xb8, 0xcc, 0xc4, 0xb5, 0xf0, 0xf3, 0x14, 0xba, 0x83, 0xdb,
	0x69, 0x34, 0x7a, 0x13, 0x7f, 0x30, 0xf7, 0xee, 0x64, 0x23, 0xf9, 0x20, 0x47, 0xf6, 0xcf, 0xf0,
	0x69, 0xe5, 0xdd, 0xb5, 0x18, 0xef, 0x42, 0x47, 0x95, 0x6b, 0xcd, 0x82, 0xd8, 0xee, 0x43, 0xad,
	0x49, 0x88, 0x97, 0x21, 0xa4, 0xaa, 0x4b, 0x54, 0xd7, 0x88, 0x3f, 0x0c, 0xc0, 0x65, 0xa0, 0xca,
	0xa1, 0x95, 0xa8, 0xff, 0xbf, 0xf7, 0xf4, 0xf2, 0xbd, 0xc7, 0xd2, 0x7a, 0x4f, 0x46, 0x63, 0x6a,
	0xd9, 0x21, 0x74, 0x5c, 0x72, 0x13, 0x12, 0xa6, 0xf8, 0xe6, 0xdd, 0x23, 0x2e, 0x84, 0xf6, 0x73,
	0xd8, 0x2f, 0x0a, 0x5f, 0xb3, 0x09, 0xb7, 0x49, 0x02, 0xc4, 0x63, 0x83, 0xdc, 0x15, 0x23, 0x60,
	0x4f, 0x01, 0x97, 0xe1, 0x7f, 0x20, 0x92, 0x67, 0x59, 0x26, 0x5b, 0xbd, 0x8e, 0x64, 0xa5, 0xc4,
	0x96, 0xd4, 0x95, 0xdf, 0x0c, 0xd8, 0x7d, 0xe5, 0xf9, 0xe3, 0x39, 0x19, 0x5c, 0xf5, 0xd9, 0xaa,
	0x4e, 0xd4, 0x11, 0x7c, 0x9b, 0x82, 0xef, 0x26, 0x47, 0x1e, 0x5c, 0xf5, 0xd3, 0x59, 0xc2, 0x0b,
	0x27, 0x71, 0x29, 0x12, 0x6b, 0x74, 0x04, 0x30, 0x9c, 0xfa, 0x73, 0x3a, 0xf9, 0x21, 0xa0, 0x4c,
	0xbc, 0xc0, 0xa6, 0xdb, 0x94, 0x27, 0x5f, 0x53, 0xa6, 0x91, 0x51, 0xd7, 0xc9, 0xe0, 0x1d, 0x59,
	0x37, 0x67, 0x1d, 0xc9, 0xdb, 0x7b, 0xbf, 0x05, 0x0d, 0xf9, 0x5a, 0xd0, 0x53, 0x68, 0x26, 0xa3,
	0x26, 0xda, 0x13, 0x5e, 0xe6, 0x66, 0x57, 0xbc, 0x9f, 0x3b, 0x95, 0x68, 0xf6, 0x06, 0x7a, 0x06,
	0x2d, 0x6d, 0x44, 0x42, 0x6d, 0x2d, 0x8f, 0xf4, 0xfb, 0x07, 0x85, 0xf3, 0x04, 0xe1, 0x2b, 0x80,
	0x74, 0x1c, 0x41, 0x42, 0x51, 0x61, 0xc2, 0xc1, 0xed, 0xfc, 0x71, 0x72, 0xfd, 0x15, 0xb4, 0xb4,
	0xce, 0x8d, 0x70, 0xae, 0x95, 0x6b, 0xa3, 0x06, 0x3e, 0x2c, 0x95, 0x25, 0x48, 0xe7, 0xf0, 0x58,
	0x6f, 0x88, 0x48, 0xd8, 0x5c, 0xd2, 0xf5, 0xb1, 0x55, 0x14, 0x24, 0x20, 0x2f, 0xe1, 0x93, 0x4c,
	0x9f, 0x41, 0xe2, 0xe3, 0xb2, 0x16, 0x88, 0x3b, 0x25, 0x92, 0x04, 0xe7, 0x3a, 0x1e, 0xd2, 0xf4,
	0xb1, 0x1a, 0x1d, 0xa5, 0x34, 0x94, 0xcc, 0xe8, 0xb8, 0x5b, 0x25, 0xd6, 0x61, 0x8b, 0xb5, 0x5e,
	0xc2, 0x56, 0xb6, 0x29, 0x09, 0x5b, 0xdd, 0x22, 0x64, 0x0c, 0xd3, 0x04, 0x96, 0x31, 0x2c, 0xbc,
	0x2f, 0x19, 0xc3, 0x62, 0x9e, 0xdb, 0x1b, 0x68, 0x0c, 0x07, 0x15, 0x95, 0x1c, 0xd9, 0x82, 0xeb,
	0x95, 0x2d, 0x02, 0x7f, 0xbe, 0xf2, 0x9b, 0x44, 0xcb, 0x77, 0xd0, 0x2e, 0x56, 0x56, 0x91, 0x74,
	0x47, 0x5a, 0x76, 0x16, 0x4b, 0xb9, 0xf4, 0xbf, 0xba, 0x28, 0x4b, 0x5a, 0x8b, 0x25, 0x47, 0xc2,
	0x56, 0xd6, 0x4c, 0x09, 0x5b, 0x5d, 0xf2, 0xec, 0x8d, 0x17, 0x3b, 0x7f, 0xdd, 0x77, 0x8d, 0xbf,
	0xef, 0xbb, 0xc6, 0x3f, 0xf7, 0x5d, 0xe3, 0xcf, 0x7f, 0xbb, 0x1b, 0xc3, 0x86, 0xf8, 0xbd, 0x3c,
	0xfb, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x64, 0xc8, 0x35, 0xcb, 0x84, 0x0e, 0x00, 0x00,
}
