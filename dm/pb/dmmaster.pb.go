// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dmmaster.proto

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		dmmaster.proto
		dmworker.proto

	It has these top-level messages:
		StartTaskRequest
		StartTaskResponse
		OperateTaskRequest
		OperateTaskResponse
		UpdateTaskRequest
		QueryStatusListRequest
		QueryStatusListResponse
		ApplyForDDLLockRequest
		UnlockDDLLockRequest
		CommonTaskResponse
		RefreshWorkerTasksRequest
		RefreshWorkerTasksMsg
		RefreshWorkerTasksResponse
		StartSubTaskRequest
		OperateSubTaskRequest
		OperateSubTaskResponse
		UpdateSubTaskRequest
		QueryStatusRequest
		HandleSQLsRequest
		CommonWorkerResponse
		QueryStatusResponse
		CheckStatus
		DumpStatus
		LoadStatus
		SyncStatus
		SubTaskStatus
		SubTaskStatusList
		ProcessResult
		ProcessError
*/
package pb

import (
	"fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"

	io "io"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StartTaskRequest struct {
	Task    string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Workers []string `protobuf:"bytes,2,rep,name=workers" json:"workers,omitempty"`
}

func (m *StartTaskRequest) Reset()                    { *m = StartTaskRequest{} }
func (m *StartTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*StartTaskRequest) ProtoMessage()               {}
func (*StartTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{0} }

func (m *StartTaskRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *StartTaskRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

type StartTaskResponse struct {
	Result  bool                    `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                  `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers []*CommonWorkerResponse `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
}

func (m *StartTaskResponse) Reset()                    { *m = StartTaskResponse{} }
func (m *StartTaskResponse) String() string            { return proto.CompactTextString(m) }
func (*StartTaskResponse) ProtoMessage()               {}
func (*StartTaskResponse) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{1} }

func (m *StartTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *StartTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *StartTaskResponse) GetWorkers() []*CommonWorkerResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

type OperateTaskRequest struct {
	Op      TaskOp   `protobuf:"varint,1,opt,name=op,proto3,enum=pb.TaskOp" json:"op,omitempty"`
	Name    string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Workers []string `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
}

func (m *OperateTaskRequest) Reset()                    { *m = OperateTaskRequest{} }
func (m *OperateTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*OperateTaskRequest) ProtoMessage()               {}
func (*OperateTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{2} }

func (m *OperateTaskRequest) GetOp() TaskOp {
	if m != nil {
		return m.Op
	}
	return TaskOp_InvalidOp
}

func (m *OperateTaskRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *OperateTaskRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

type OperateTaskResponse struct {
	Op      TaskOp                    `protobuf:"varint,1,opt,name=op,proto3,enum=pb.TaskOp" json:"op,omitempty"`
	Result  bool                      `protobuf:"varint,2,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                    `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers []*OperateSubTaskResponse `protobuf:"bytes,4,rep,name=workers" json:"workers,omitempty"`
}

func (m *OperateTaskResponse) Reset()                    { *m = OperateTaskResponse{} }
func (m *OperateTaskResponse) String() string            { return proto.CompactTextString(m) }
func (*OperateTaskResponse) ProtoMessage()               {}
func (*OperateTaskResponse) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{3} }

func (m *OperateTaskResponse) GetOp() TaskOp {
	if m != nil {
		return m.Op
	}
	return TaskOp_InvalidOp
}

func (m *OperateTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *OperateTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *OperateTaskResponse) GetWorkers() []*OperateSubTaskResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

// refine when we refactor filter, column-mapping, etc.
type UpdateTaskRequest struct {
	Task    string   `protobuf:"bytes,1,opt,name=task,proto3" json:"task,omitempty"`
	Workers []string `protobuf:"bytes,2,rep,name=workers" json:"workers,omitempty"`
}

func (m *UpdateTaskRequest) Reset()                    { *m = UpdateTaskRequest{} }
func (m *UpdateTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateTaskRequest) ProtoMessage()               {}
func (*UpdateTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{4} }

func (m *UpdateTaskRequest) GetTask() string {
	if m != nil {
		return m.Task
	}
	return ""
}

func (m *UpdateTaskRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

type QueryStatusListRequest struct {
	Name    string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Workers []string `protobuf:"bytes,2,rep,name=workers" json:"workers,omitempty"`
}

func (m *QueryStatusListRequest) Reset()                    { *m = QueryStatusListRequest{} }
func (m *QueryStatusListRequest) String() string            { return proto.CompactTextString(m) }
func (*QueryStatusListRequest) ProtoMessage()               {}
func (*QueryStatusListRequest) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{5} }

func (m *QueryStatusListRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryStatusListRequest) GetWorkers() []string {
	if m != nil {
		return m.Workers
	}
	return nil
}

type QueryStatusListResponse struct {
	Result  bool                   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg     string                 `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	Workers []*QueryStatusResponse `protobuf:"bytes,3,rep,name=workers" json:"workers,omitempty"`
}

func (m *QueryStatusListResponse) Reset()                    { *m = QueryStatusListResponse{} }
func (m *QueryStatusListResponse) String() string            { return proto.CompactTextString(m) }
func (*QueryStatusListResponse) ProtoMessage()               {}
func (*QueryStatusListResponse) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{6} }

func (m *QueryStatusListResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *QueryStatusListResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *QueryStatusListResponse) GetWorkers() []*QueryStatusResponse {
	if m != nil {
		return m.Workers
	}
	return nil
}

type ApplyForDDLLockRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Ddl  string `protobuf:"bytes,2,opt,name=ddl,proto3" json:"ddl,omitempty"`
}

func (m *ApplyForDDLLockRequest) Reset()                    { *m = ApplyForDDLLockRequest{} }
func (m *ApplyForDDLLockRequest) String() string            { return proto.CompactTextString(m) }
func (*ApplyForDDLLockRequest) ProtoMessage()               {}
func (*ApplyForDDLLockRequest) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{7} }

func (m *ApplyForDDLLockRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ApplyForDDLLockRequest) GetDdl() string {
	if m != nil {
		return m.Ddl
	}
	return ""
}

type UnlockDDLLockRequest struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	LockID string `protobuf:"bytes,2,opt,name=lockID,proto3" json:"lockID,omitempty"`
}

func (m *UnlockDDLLockRequest) Reset()                    { *m = UnlockDDLLockRequest{} }
func (m *UnlockDDLLockRequest) String() string            { return proto.CompactTextString(m) }
func (*UnlockDDLLockRequest) ProtoMessage()               {}
func (*UnlockDDLLockRequest) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{8} }

func (m *UnlockDDLLockRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UnlockDDLLockRequest) GetLockID() string {
	if m != nil {
		return m.LockID
	}
	return ""
}

type CommonTaskResponse struct {
	Result bool   `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *CommonTaskResponse) Reset()                    { *m = CommonTaskResponse{} }
func (m *CommonTaskResponse) String() string            { return proto.CompactTextString(m) }
func (*CommonTaskResponse) ProtoMessage()               {}
func (*CommonTaskResponse) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{9} }

func (m *CommonTaskResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *CommonTaskResponse) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type RefreshWorkerTasksRequest struct {
}

func (m *RefreshWorkerTasksRequest) Reset()         { *m = RefreshWorkerTasksRequest{} }
func (m *RefreshWorkerTasksRequest) String() string { return proto.CompactTextString(m) }
func (*RefreshWorkerTasksRequest) ProtoMessage()    {}
func (*RefreshWorkerTasksRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorDmmaster, []int{10}
}

type RefreshWorkerTasksMsg struct {
	Worker string `protobuf:"bytes,1,opt,name=worker,proto3" json:"worker,omitempty"`
	Msg    string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *RefreshWorkerTasksMsg) Reset()                    { *m = RefreshWorkerTasksMsg{} }
func (m *RefreshWorkerTasksMsg) String() string            { return proto.CompactTextString(m) }
func (*RefreshWorkerTasksMsg) ProtoMessage()               {}
func (*RefreshWorkerTasksMsg) Descriptor() ([]byte, []int) { return fileDescriptorDmmaster, []int{11} }

func (m *RefreshWorkerTasksMsg) GetWorker() string {
	if m != nil {
		return m.Worker
	}
	return ""
}

func (m *RefreshWorkerTasksMsg) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

type RefreshWorkerTasksResponse struct {
	Result  bool                     `protobuf:"varint,1,opt,name=result,proto3" json:"result,omitempty"`
	Workers []*RefreshWorkerTasksMsg `protobuf:"bytes,2,rep,name=workers" json:"workers,omitempty"`
}

func (m *RefreshWorkerTasksResponse) Reset()         { *m = RefreshWorkerTasksResponse{} }
func (m *RefreshWorkerTasksResponse) String() string { return proto.CompactTextString(m) }
func (*RefreshWorkerTasksResponse) ProtoMessage()    {}
func (*RefreshWorkerTasksResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorDmmaster, []int{12}
}

func (m *RefreshWorkerTasksResponse) GetResult() bool {
	if m != nil {
		return m.Result
	}
	return false
}

func (m *RefreshWorkerTasksResponse) GetWorkers() []*RefreshWorkerTasksMsg {
	if m != nil {
		return m.Workers
	}
	return nil
}

func init() {
	proto.RegisterType((*StartTaskRequest)(nil), "pb.StartTaskRequest")
	proto.RegisterType((*StartTaskResponse)(nil), "pb.StartTaskResponse")
	proto.RegisterType((*OperateTaskRequest)(nil), "pb.OperateTaskRequest")
	proto.RegisterType((*OperateTaskResponse)(nil), "pb.OperateTaskResponse")
	proto.RegisterType((*UpdateTaskRequest)(nil), "pb.UpdateTaskRequest")
	proto.RegisterType((*QueryStatusListRequest)(nil), "pb.QueryStatusListRequest")
	proto.RegisterType((*QueryStatusListResponse)(nil), "pb.QueryStatusListResponse")
	proto.RegisterType((*ApplyForDDLLockRequest)(nil), "pb.ApplyForDDLLockRequest")
	proto.RegisterType((*UnlockDDLLockRequest)(nil), "pb.UnlockDDLLockRequest")
	proto.RegisterType((*CommonTaskResponse)(nil), "pb.CommonTaskResponse")
	proto.RegisterType((*RefreshWorkerTasksRequest)(nil), "pb.RefreshWorkerTasksRequest")
	proto.RegisterType((*RefreshWorkerTasksMsg)(nil), "pb.RefreshWorkerTasksMsg")
	proto.RegisterType((*RefreshWorkerTasksResponse)(nil), "pb.RefreshWorkerTasksResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Master service

type MasterClient interface {
	StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskResponse, error)
	OperateTask(ctx context.Context, in *OperateTaskRequest, opts ...grpc.CallOption) (*OperateTaskResponse, error)
	UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*CommonTaskResponse, error)
	QueryStatus(ctx context.Context, in *QueryStatusListRequest, opts ...grpc.CallOption) (*QueryStatusListResponse, error)
	// used by dm-worker, maybe should return response with DDL lock ID
	ApplyForDDLLock(ctx context.Context, in *ApplyForDDLLockRequest, opts ...grpc.CallOption) (*CommonTaskResponse, error)
	// used by dmctl to manually unlock DDL lock
	UnlockDDLLock(ctx context.Context, in *UnlockDDLLockRequest, opts ...grpc.CallOption) (*CommonTaskResponse, error)
	// refine to support specify dm-worker
	HandleSQLs(ctx context.Context, in *HandleSQLsRequest, opts ...grpc.CallOption) (*CommonTaskResponse, error)
	// used by dmctl, to force refresh the task -> workers mapper
	// it should be used rarely only when task -> workers mapper corrupted
	RefreshWorkerTasks(ctx context.Context, in *RefreshWorkerTasksRequest, opts ...grpc.CallOption) (*RefreshWorkerTasksResponse, error)
}

type masterClient struct {
	cc *grpc.ClientConn
}

func NewMasterClient(cc *grpc.ClientConn) MasterClient {
	return &masterClient{cc}
}

func (c *masterClient) StartTask(ctx context.Context, in *StartTaskRequest, opts ...grpc.CallOption) (*StartTaskResponse, error) {
	out := new(StartTaskResponse)
	err := grpc.Invoke(ctx, "/pb.Master/StartTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) OperateTask(ctx context.Context, in *OperateTaskRequest, opts ...grpc.CallOption) (*OperateTaskResponse, error) {
	out := new(OperateTaskResponse)
	err := grpc.Invoke(ctx, "/pb.Master/OperateTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UpdateTask(ctx context.Context, in *UpdateTaskRequest, opts ...grpc.CallOption) (*CommonTaskResponse, error) {
	out := new(CommonTaskResponse)
	err := grpc.Invoke(ctx, "/pb.Master/UpdateTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) QueryStatus(ctx context.Context, in *QueryStatusListRequest, opts ...grpc.CallOption) (*QueryStatusListResponse, error) {
	out := new(QueryStatusListResponse)
	err := grpc.Invoke(ctx, "/pb.Master/QueryStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) ApplyForDDLLock(ctx context.Context, in *ApplyForDDLLockRequest, opts ...grpc.CallOption) (*CommonTaskResponse, error) {
	out := new(CommonTaskResponse)
	err := grpc.Invoke(ctx, "/pb.Master/ApplyForDDLLock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) UnlockDDLLock(ctx context.Context, in *UnlockDDLLockRequest, opts ...grpc.CallOption) (*CommonTaskResponse, error) {
	out := new(CommonTaskResponse)
	err := grpc.Invoke(ctx, "/pb.Master/UnlockDDLLock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) HandleSQLs(ctx context.Context, in *HandleSQLsRequest, opts ...grpc.CallOption) (*CommonTaskResponse, error) {
	out := new(CommonTaskResponse)
	err := grpc.Invoke(ctx, "/pb.Master/HandleSQLs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterClient) RefreshWorkerTasks(ctx context.Context, in *RefreshWorkerTasksRequest, opts ...grpc.CallOption) (*RefreshWorkerTasksResponse, error) {
	out := new(RefreshWorkerTasksResponse)
	err := grpc.Invoke(ctx, "/pb.Master/RefreshWorkerTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Master service

type MasterServer interface {
	StartTask(context.Context, *StartTaskRequest) (*StartTaskResponse, error)
	OperateTask(context.Context, *OperateTaskRequest) (*OperateTaskResponse, error)
	UpdateTask(context.Context, *UpdateTaskRequest) (*CommonTaskResponse, error)
	QueryStatus(context.Context, *QueryStatusListRequest) (*QueryStatusListResponse, error)
	// used by dm-worker, maybe should return response with DDL lock ID
	ApplyForDDLLock(context.Context, *ApplyForDDLLockRequest) (*CommonTaskResponse, error)
	// used by dmctl to manually unlock DDL lock
	UnlockDDLLock(context.Context, *UnlockDDLLockRequest) (*CommonTaskResponse, error)
	// refine to support specify dm-worker
	HandleSQLs(context.Context, *HandleSQLsRequest) (*CommonTaskResponse, error)
	// used by dmctl, to force refresh the task -> workers mapper
	// it should be used rarely only when task -> workers mapper corrupted
	RefreshWorkerTasks(context.Context, *RefreshWorkerTasksRequest) (*RefreshWorkerTasksResponse, error)
}

func RegisterMasterServer(s *grpc.Server, srv MasterServer) {
	s.RegisterService(&_Master_serviceDesc, srv)
}

func _Master_StartTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).StartTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/StartTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).StartTask(ctx, req.(*StartTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_OperateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).OperateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/OperateTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).OperateTask(ctx, req.(*OperateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UpdateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UpdateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UpdateTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UpdateTask(ctx, req.(*UpdateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_QueryStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryStatusListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).QueryStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/QueryStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).QueryStatus(ctx, req.(*QueryStatusListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_ApplyForDDLLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyForDDLLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).ApplyForDDLLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/ApplyForDDLLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).ApplyForDDLLock(ctx, req.(*ApplyForDDLLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_UnlockDDLLock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockDDLLockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).UnlockDDLLock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/UnlockDDLLock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).UnlockDDLLock(ctx, req.(*UnlockDDLLockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_HandleSQLs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HandleSQLsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).HandleSQLs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/HandleSQLs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).HandleSQLs(ctx, req.(*HandleSQLsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Master_RefreshWorkerTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshWorkerTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServer).RefreshWorkerTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Master/RefreshWorkerTasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServer).RefreshWorkerTasks(ctx, req.(*RefreshWorkerTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Master_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Master",
	HandlerType: (*MasterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StartTask",
			Handler:    _Master_StartTask_Handler,
		},
		{
			MethodName: "OperateTask",
			Handler:    _Master_OperateTask_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _Master_UpdateTask_Handler,
		},
		{
			MethodName: "QueryStatus",
			Handler:    _Master_QueryStatus_Handler,
		},
		{
			MethodName: "ApplyForDDLLock",
			Handler:    _Master_ApplyForDDLLock_Handler,
		},
		{
			MethodName: "UnlockDDLLock",
			Handler:    _Master_UnlockDDLLock_Handler,
		},
		{
			MethodName: "HandleSQLs",
			Handler:    _Master_HandleSQLs_Handler,
		},
		{
			MethodName: "RefreshWorkerTasks",
			Handler:    _Master_RefreshWorkerTasks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dmmaster.proto",
}

func (m *StartTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Task) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i += copy(dAtA[i:], m.Task)
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *StartTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OperateTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *OperateTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OperateTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(m.Op))
	}
	if m.Result {
		dAtA[i] = 0x10
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x22
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateTaskRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTaskRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Task) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Task)))
		i += copy(dAtA[i:], m.Task)
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *QueryStatusListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryStatusListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			dAtA[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *QueryStatusListResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryStatusListResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ApplyForDDLLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApplyForDDLLockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Ddl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Ddl)))
		i += copy(dAtA[i:], m.Ddl)
	}
	return i, nil
}

func (m *UnlockDDLLockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockDDLLockRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.LockID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.LockID)))
		i += copy(dAtA[i:], m.LockID)
	}
	return i, nil
}

func (m *CommonTaskResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonTaskResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *RefreshWorkerTasksRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshWorkerTasksRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *RefreshWorkerTasksMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshWorkerTasksMsg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Worker) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Worker)))
		i += copy(dAtA[i:], m.Worker)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintDmmaster(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	return i, nil
}

func (m *RefreshWorkerTasksResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshWorkerTasksResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Result {
		dAtA[i] = 0x8
		i++
		if m.Result {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Workers) > 0 {
		for _, msg := range m.Workers {
			dAtA[i] = 0x12
			i++
			i = encodeVarintDmmaster(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintDmmaster(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *StartTaskRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *StartTaskResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *OperateTaskRequest) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *OperateTaskResponse) Size() (n int) {
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovDmmaster(uint64(m.Op))
	}
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *UpdateTaskRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Task)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *QueryStatusListRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, s := range m.Workers {
			l = len(s)
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *QueryStatusListResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func (m *ApplyForDDLLockRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Ddl)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *UnlockDDLLockRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.LockID)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *CommonTaskResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *RefreshWorkerTasksRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *RefreshWorkerTasksMsg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Worker)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovDmmaster(uint64(l))
	}
	return n
}

func (m *RefreshWorkerTasksResponse) Size() (n int) {
	var l int
	_ = l
	if m.Result {
		n += 2
	}
	if len(m.Workers) > 0 {
		for _, e := range m.Workers {
			l = e.Size()
			n += 1 + l + sovDmmaster(uint64(l))
		}
	}
	return n
}

func sovDmmaster(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozDmmaster(x uint64) (n int) {
	return sovDmmaster(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StartTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &CommonWorkerResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (TaskOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OperateTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OperateTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OperateTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= (TaskOp(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &OperateSubTaskResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTaskRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTaskRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTaskRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Task", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Task = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryStatusListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryStatusListRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryStatusListRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryStatusListResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryStatusListResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryStatusListResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &QueryStatusResponse{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApplyForDDLLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApplyForDDLLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApplyForDDLLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ddl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ddl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockDDLLockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockDDLLockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockDDLLockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonTaskResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonTaskResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonTaskResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshWorkerTasksRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshWorkerTasksRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshWorkerTasksRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshWorkerTasksMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshWorkerTasksMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshWorkerTasksMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Worker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Worker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshWorkerTasksResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshWorkerTasksResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshWorkerTasksResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Result = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDmmaster
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Workers = append(m.Workers, &RefreshWorkerTasksMsg{})
			if err := m.Workers[len(m.Workers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDmmaster(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthDmmaster
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDmmaster(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDmmaster
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDmmaster
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthDmmaster
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowDmmaster
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipDmmaster(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthDmmaster = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDmmaster   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("dmmaster.proto", fileDescriptorDmmaster) }

var fileDescriptorDmmaster = []byte{
	// 592 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x95, 0xdf, 0x6e, 0xd3, 0x3c,
	0x18, 0xc6, 0x97, 0xa4, 0xea, 0xf7, 0xf5, 0xad, 0x28, 0x9d, 0xd9, 0xd2, 0x2e, 0x13, 0x55, 0x95,
	0xa3, 0x1e, 0x55, 0xa2, 0xe3, 0x08, 0x69, 0xd3, 0xba, 0x55, 0x63, 0x48, 0x9d, 0xa6, 0xa5, 0x54,
	0x9c, 0x21, 0xa5, 0x8b, 0x19, 0x53, 0x93, 0xda, 0x8b, 0x1d, 0xd0, 0x2e, 0x83, 0x33, 0xee, 0x83,
	0x9b, 0xe0, 0x90, 0x4b, 0x40, 0xe5, 0x46, 0x90, 0x9d, 0xa4, 0x71, 0x93, 0xd0, 0x31, 0xce, 0x62,
	0xbb, 0xef, 0xef, 0x79, 0xff, 0x3c, 0x76, 0xa1, 0xe1, 0x05, 0x81, 0xcb, 0x38, 0x0e, 0xfb, 0x34,
	0x24, 0x9c, 0x20, 0x9d, 0xce, 0xac, 0x86, 0x17, 0x7c, 0x26, 0xe1, 0x3c, 0xdd, 0xb3, 0x8f, 0xa1,
	0x39, 0xe1, 0x6e, 0xc8, 0xdf, 0xba, 0x6c, 0xee, 0xe0, 0xbb, 0x08, 0x33, 0x8e, 0x10, 0x54, 0xb8,
	0xcb, 0xe6, 0x6d, 0xad, 0xab, 0xf5, 0x6a, 0x8e, 0xfc, 0x46, 0x6d, 0xf8, 0x2f, 0x8e, 0x63, 0x6d,
	0xbd, 0x6b, 0xf4, 0x6a, 0x4e, 0xba, 0xb4, 0xef, 0x60, 0x5b, 0x21, 0x30, 0x4a, 0x16, 0x0c, 0x23,
	0x13, 0xaa, 0x21, 0x66, 0x91, 0xcf, 0x25, 0xe4, 0x7f, 0x27, 0x59, 0xa1, 0x26, 0x18, 0x01, 0xbb,
	0x69, 0xeb, 0x92, 0x2c, 0x3e, 0xd1, 0x20, 0x03, 0x1b, 0x5d, 0xa3, 0x57, 0x1f, 0xb4, 0xfb, 0x74,
	0xd6, 0x3f, 0x25, 0x41, 0x40, 0x16, 0xef, 0xe4, 0x41, 0x0a, 0xcd, 0x24, 0xdf, 0x03, 0xba, 0xa4,
	0x38, 0x74, 0x39, 0x56, 0xd3, 0xb6, 0x40, 0x27, 0x54, 0xea, 0x35, 0x06, 0x20, 0x20, 0xe2, 0xf0,
	0x92, 0x3a, 0x3a, 0xa1, 0xa2, 0xa4, 0x85, 0x1b, 0xe0, 0x44, 0x58, 0x7e, 0xab, 0x25, 0x19, 0xeb,
	0x25, 0x7d, 0xd1, 0xe0, 0xd9, 0x9a, 0x40, 0x52, 0xd5, 0x26, 0x85, 0xac, 0x62, 0xbd, 0xac, 0x62,
	0x23, 0xab, 0xf8, 0x65, 0xa6, 0x5b, 0x91, 0x15, 0x5b, 0x02, 0x95, 0xe8, 0x4d, 0xa2, 0x99, 0x2a,
	0x99, 0xe5, 0x34, 0x84, 0xed, 0x29, 0xf5, 0x72, 0x25, 0x3f, 0x6e, 0x52, 0x67, 0x60, 0x5e, 0x45,
	0x38, 0xbc, 0x9f, 0x70, 0x97, 0x47, 0x6c, 0x7c, 0xcb, 0xb8, 0xc2, 0x91, 0xed, 0xd1, 0xca, 0xdb,
	0x93, 0xe3, 0x7c, 0x82, 0x56, 0x81, 0xf3, 0xe8, 0xb9, 0xbf, 0xc8, 0xcf, 0xbd, 0x25, 0xba, 0xa0,
	0x70, 0x8b, 0x2d, 0x38, 0x02, 0x73, 0x48, 0xa9, 0x7f, 0x7f, 0x46, 0xc2, 0xd1, 0x68, 0x3c, 0x26,
	0xd7, 0xf3, 0x4d, 0xf9, 0x37, 0xc1, 0xf0, 0x3c, 0x3f, 0x95, 0xf4, 0x3c, 0xdf, 0x3e, 0x81, 0x9d,
	0xe9, 0xc2, 0x27, 0xd7, 0xf3, 0xbf, 0x88, 0x36, 0xa1, 0x2a, 0x7e, 0xf9, 0x66, 0x94, 0x00, 0x92,
	0x95, 0x7d, 0x04, 0x28, 0xf6, 0xe6, 0xbf, 0xd9, 0xdd, 0xde, 0x87, 0x3d, 0x07, 0x7f, 0x08, 0x31,
	0xfb, 0x18, 0x9b, 0x5b, 0x60, 0x58, 0x92, 0x88, 0x3d, 0x84, 0xdd, 0xe2, 0xe1, 0x05, 0xbb, 0x11,
	0xfc, 0xb8, 0x09, 0x49, 0x8e, 0xc9, 0xaa, 0x84, 0x7f, 0x0b, 0x56, 0x19, 0xff, 0x81, 0x3c, 0x0f,
	0xd6, 0x67, 0x5d, 0x1f, 0xec, 0x89, 0x61, 0x94, 0xe6, 0xb2, 0x1a, 0xc7, 0xe0, 0x5b, 0x05, 0xaa,
	0x17, 0xf2, 0x7d, 0x41, 0xaf, 0xa0, 0xb6, 0x7a, 0x03, 0xd0, 0x8e, 0x88, 0xcd, 0x3f, 0x2a, 0xd6,
	0x6e, 0x6e, 0x37, 0xce, 0xc8, 0xde, 0x42, 0xc7, 0x50, 0x57, 0xee, 0x1a, 0x32, 0x95, 0xcb, 0xa0,
	0xc6, 0xb7, 0x0a, 0xfb, 0x2b, 0xc2, 0x21, 0x40, 0x76, 0x35, 0x90, 0x14, 0x2a, 0x5c, 0x15, 0xcb,
	0xcc, 0x9e, 0x95, 0x5c, 0xf8, 0x39, 0xd4, 0x15, 0xdb, 0x21, 0x2b, 0xe7, 0x43, 0xe5, 0x9e, 0x58,
	0xfb, 0xa5, 0x67, 0x2b, 0xd2, 0x6b, 0x78, 0x9a, 0x33, 0x68, 0x4c, 0x2b, 0x77, 0xed, 0x86, 0x94,
	0x4e, 0xe1, 0xc9, 0x9a, 0x53, 0x91, 0x7c, 0x14, 0xcb, 0xcc, 0xbb, 0x01, 0x72, 0x08, 0x70, 0xee,
	0x2e, 0x3c, 0x1f, 0x4f, 0xae, 0xc6, 0x2c, 0x6e, 0x4b, 0xb6, 0x7e, 0x38, 0x7c, 0x0a, 0xa8, 0x68,
	0x00, 0xf4, 0xbc, 0xdc, 0x18, 0x29, 0xae, 0xf3, 0xa7, 0xe3, 0x14, 0x7b, 0xd2, 0xfc, 0xbe, 0xec,
	0x68, 0x3f, 0x96, 0x1d, 0xed, 0xe7, 0xb2, 0xa3, 0x7d, 0xfd, 0xd5, 0xd9, 0x9a, 0x55, 0xe5, 0x3f,
	0xd1, 0xc1, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xce, 0x52, 0x47, 0x11, 0xaf, 0x06, 0x00, 0x00,
}
